"""
Strategy Base Class

Defines the abstract interface for all trading strategies in QETE.

Every strategy must implement:
- generate_signals(): Analyze market data and produce trading signals

Signals represent actionable trading opportunities with:
- Ticker: Which market to trade
- Side: BUY or SELL
- Price: Target execution price
- Size: Position size (contracts)
- Strategy name: For attribution and logging
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict, Any

from kalshi_qete.src.engine.scanner import MarketWithOrderbook


class Side(Enum):
    """Trading side enumeration."""
    BUY = "BUY"
    SELL = "SELL"
    
    def __str__(self) -> str:
        return self.value


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Represents an actionable trading opportunity with all information
    needed for execution.
    
    Attributes:
        ticker: Market ticker to trade
        side: BUY or SELL
        price: Target execution price (in cents, 1-99)
        size: Number of contracts
        strategy_name: Name of generating strategy
        confidence: Signal confidence (0.0-1.0)
        timestamp: When signal was generated
        metadata: Additional strategy-specific data
        
    Example:
        >>> signal = Signal(
        ...     ticker="KXGOP-TRUMP",
        ...     side=Side.BUY,
        ...     price=45,
        ...     size=100,
        ...     strategy_name="StructuralArb"
        ... )
    """
    ticker: str
    side: Side
    price: int  # Price in cents (1-99)
    size: int   # Number of contracts
    strategy_name: str
    confidence: float = 1.0
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        return (
            f"Signal({self.side} {self.size}x {self.ticker} @ {self.price}Â¢ "
            f"[{self.strategy_name}])"
        )
    
    @property
    def notional_value(self) -> float:
        """Total cost/proceeds in dollars."""
        return (self.price * self.size) / 100
    
    @property
    def max_profit(self) -> float:
        """Maximum profit potential in dollars."""
        if self.side == Side.BUY:
            return ((100 - self.price) * self.size) / 100
        else:  # SELL
            return (self.price * self.size) / 100
    
    @property
    def max_loss(self) -> float:
        """Maximum loss potential in dollars."""
        if self.side == Side.BUY:
            return (self.price * self.size) / 100
        else:  # SELL
            return ((100 - self.price) * self.size) / 100


@dataclass
class SignalGroup:
    """
    A group of related signals (e.g., all legs of an arbitrage).
    
    Used when a strategy generates multiple signals that should be
    executed together as a package.
    
    Attributes:
        signals: List of individual signals
        group_name: Descriptive name for the signal group
        event_ticker: Related event ticker
        expected_profit: Net expected profit if all legs execute
        strategy_name: Name of generating strategy
    """
    signals: List[Signal]
    group_name: str
    event_ticker: str
    expected_profit: float  # In dollars
    strategy_name: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        return (
            f"SignalGroup({self.group_name}): {len(self.signals)} signals, "
            f"E[Profit]=${self.expected_profit:.2f}"
        )
    
    @property
    def total_cost(self) -> float:
        """Total capital required for all signals."""
        return sum(s.notional_value for s in self.signals if s.side == Side.BUY)
    
    @property
    def total_premium(self) -> float:
        """Total premium collected from sells."""
        return sum(s.notional_value for s in self.signals if s.side == Side.SELL)


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Strategies analyze market data and generate actionable signals.
    Each strategy should:
    1. Have a unique name for identification
    2. Implement generate_signals() to produce trading signals
    3. Optionally implement validate_signal() for pre-execution checks
    
    Example Implementation:
        >>> class MyStrategy(Strategy):
        ...     @property
        ...     def name(self) -> str:
        ...         return "MyStrategy"
        ...     
        ...     def generate_signals(self, markets):
        ...         signals = []
        ...         # ... analysis logic ...
        ...         return signals
    """
    
    @property
    @abstractmethod
    def name(self) -> str:
        """
        Unique strategy name for identification and logging.
        
        Returns:
            Strategy name string
        """
        pass
    
    @abstractmethod
    def generate_signals(
        self, 
        markets: List[MarketWithOrderbook]
    ) -> List[Signal]:
        """
        Analyze markets and generate trading signals.
        
        This is the core method where strategy logic lives.
        
        Args:
            markets: List of markets with orderbook data
            
        Returns:
            List of Signal objects (may be empty if no opportunities)
        """
        pass
    
    def generate_signal_groups(
        self,
        markets: List[MarketWithOrderbook]
    ) -> List[SignalGroup]:
        """
        Generate grouped signals for multi-leg strategies.
        
        Override this method for strategies that produce related signal
        groups (e.g., arbitrage legs that should execute together).
        
        Default implementation wraps individual signals.
        
        Args:
            markets: List of markets with orderbook data
            
        Returns:
            List of SignalGroup objects
        """
        signals = self.generate_signals(markets)
        if not signals:
            return []
        
        # Default: wrap each signal in its own group
        return [
            SignalGroup(
                signals=[s],
                group_name=s.ticker,
                event_ticker=s.metadata.get("event_ticker", "unknown"),
                expected_profit=s.max_profit,
                strategy_name=self.name
            )
            for s in signals
        ]
    
    def validate_signal(self, signal: Signal) -> bool:
        """
        Validate a signal before execution.
        
        Override to add strategy-specific validation logic.
        
        Args:
            signal: Signal to validate
            
        Returns:
            True if signal is valid for execution
        """
        # Basic validation
        if signal.price < 1 or signal.price > 99:
            return False
        if signal.size <= 0:
            return False
        return True
    
    def __str__(self) -> str:
        return f"Strategy({self.name})"
    
    def __repr__(self) -> str:
        return self.__str__()

