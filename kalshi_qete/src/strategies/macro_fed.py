"""
Macro Fed Correlation Strategy

Correlates real-world Treasury yield movements with Kalshi Fed prediction markets.

Strategy Logic:
- Monitor 13-Week T-Bill yield (^IRX) as a proxy for short-term rate expectations
- Calculate Z-score of yield vs rolling window
- Generate signals when yield moves significantly but Kalshi probabilities lag

Signal Generation:
- Z-Score > +2.0 (Yield Spike) + Kalshi "Rate Hike" unchanged ‚Üí BUY HIKE / SELL CUT
- Z-Score < -2.0 (Yield Dump) + Kalshi "Rate Cut" unchanged ‚Üí BUY CUT / SELL HIKE

Usage:
    from kalshi_qete.src.strategies.macro_fed import MacroFedStrategy
    from kalshi_qete.src.adapters.yahoo import YahooAdapter
    from kalshi_qete.src.adapters.kalshi_adapter import KalshiAdapter
    
    yahoo = YahooAdapter()
    kalshi = KalshiAdapter(key_id, key_path)
    
    strategy = MacroFedStrategy(yahoo, kalshi)
    signals = await strategy.run()
"""

import asyncio
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Tuple
from enum import Enum

from kalshi_qete.src.strategies.base import Strategy, Signal, SignalGroup, Side
from kalshi_qete.src.adapters.yahoo import YahooAdapter, HistoricalData
from kalshi_qete.src.adapters.kalshi_adapter import KalshiAdapter
from kalshi_qete.src.engine.scanner import MarketScanner, MarketWithOrderbook
from kalshi_qete.src.db.models import MarketPricing

logger = logging.getLogger(__name__)


class FedAction(Enum):
    """Possible Fed actions."""
    HIKE = "HIKE"   # Rate increase
    CUT = "CUT"     # Rate decrease
    HOLD = "HOLD"   # No change


@dataclass
class YieldSnapshot:
    """
    Snapshot of Treasury yield with statistical context.
    """
    ticker: str
    current_yield: float
    mean_yield: float
    std_dev: float
    z_score: float
    period: str
    data_points: int
    timestamp: datetime = field(default_factory=datetime.now)
    
    @property
    def is_spike(self) -> bool:
        """True if z-score indicates significant upward move."""
        return self.z_score > 2.0
    
    @property
    def is_dump(self) -> bool:
        """True if z-score indicates significant downward move."""
        return self.z_score < -2.0
    
    @property
    def signal_direction(self) -> Optional[FedAction]:
        """
        Implied Fed action based on yield movement.
        
        Higher yields ‚Üí Market expects hikes
        Lower yields ‚Üí Market expects cuts
        """
        if self.is_spike:
            return FedAction.HIKE
        elif self.is_dump:
            return FedAction.CUT
        return None
    
    def __str__(self) -> str:
        status = "SPIKE üìà" if self.is_spike else ("DUMP üìâ" if self.is_dump else "normal")
        return (
            f"YieldSnapshot({self.ticker}): {self.current_yield:.4f}% "
            f"(z={self.z_score:+.2f}, {status})"
        )


@dataclass
class FedMarketSnapshot:
    """
    Snapshot of Kalshi Fed prediction market state.
    """
    series_ticker: str
    hike_markets: List[MarketWithOrderbook]
    cut_markets: List[MarketWithOrderbook]
    hold_markets: List[MarketWithOrderbook]
    total_hike_prob: float  # Sum of implied probs for any hike
    total_cut_prob: float   # Sum of implied probs for any cut
    hold_prob: float        # Probability of no change
    timestamp: datetime = field(default_factory=datetime.now)
    
    def __str__(self) -> str:
        return (
            f"FedMarketSnapshot: Hike={self.total_hike_prob:.1f}%, "
            f"Cut={self.total_cut_prob:.1f}%, Hold={self.hold_prob:.1f}%"
        )


@dataclass
class CorrelationSignal:
    """
    Signal generated by the correlation strategy.
    
    Includes both the yield context and the Kalshi market action.
    """
    signal: Signal
    yield_snapshot: YieldSnapshot
    kalshi_market: MarketWithOrderbook
    rationale: str
    confidence: float
    
    def __str__(self) -> str:
        return (
            f"CorrelationSignal: {self.signal.side.value} {self.signal.ticker} @ {self.signal.price}¬¢ "
            f"| {self.rationale}"
        )


class MacroFedStrategy(Strategy):
    """
    Correlation strategy between Treasury yields and Kalshi Fed markets.
    
    This strategy exploits the lag between real-world rate movements
    (reflected in Treasury yields) and Kalshi prediction market updates.
    
    Parameters:
        z_score_threshold: Minimum z-score to trigger signal (default: 2.0)
        rolling_period: Period for calculating rolling stats (default: 5d)
        rolling_interval: Interval for rolling data (default: 1h)
        min_prob_change: Minimum probability change to consider "unchanged" (default: 5%)
        default_size: Default contract size for signals (default: 10)
    
    Example:
        >>> strategy = MacroFedStrategy(yahoo_adapter, kalshi_adapter)
        >>> signals = await strategy.run()
        >>> for s in signals:
        ...     print(s)
    """
    
    # Fed-related series tickers
    FED_SERIES = [
        "KXFED",           # Fed Funds Rate decisions
        "KXFEDDECISION",   # Fed meeting decisions
    ]
    
    # Specific upcoming Fed meeting events
    # Format: KXFED-YYMMM where YY is year (26=2026) and MMM is month
    FED_MEETING_EVENTS = [
        "KXFED-26JAN",   # January 2026 Fed meeting
        "KXFED-26MAR",   # March 2026
        "KXFED-26APR",   # April 2026 (Note: sometimes 27APR for 2027)
        "KXFED-26JUN",   # June 2026
        "KXFED-26JUL",   # July 2026
        "KXFED-26SEP",   # September 2026
        "KXFED-26OCT",   # October 2026
        "KXFED-26DEC",   # December 2026
        "KXFED-27JAN",   # January 2027
        "KXFED-27MAR",   # March 2027
        "KXFED-27APR",   # April 2027
    ]
    
    # Keywords to identify market types
    HIKE_KEYWORDS = ["hike", "increase", "raise", "higher", "above", "at least"]
    CUT_KEYWORDS = ["cut", "decrease", "lower", "below", "reduction"]
    HOLD_KEYWORDS = ["hold", "unchanged", "no change", "same"]
    
    def __init__(
        self,
        yahoo_adapter: YahooAdapter,
        kalshi_adapter: KalshiAdapter,
        z_score_threshold: float = 2.0,
        rolling_period: str = "5d",
        rolling_interval: str = "1h",
        min_prob_change: float = 5.0,
        default_size: int = 10,
    ):
        self.yahoo = yahoo_adapter
        self.kalshi = kalshi_adapter
        self.z_score_threshold = z_score_threshold
        self.rolling_period = rolling_period
        self.rolling_interval = rolling_interval
        self.min_prob_change = min_prob_change
        self.default_size = default_size
        
        self.scanner = MarketScanner(kalshi_adapter)
        
        # State tracking
        self._last_yield: Optional[YieldSnapshot] = None
        self._last_fed_snapshot: Optional[FedMarketSnapshot] = None
        self._yield_history: List[YieldSnapshot] = []
        self._signals: List[CorrelationSignal] = []
        
        logger.info(
            f"MacroFedStrategy initialized: z_threshold={z_score_threshold}, "
            f"period={rolling_period}, interval={rolling_interval}"
        )
    
    @property
    def name(self) -> str:
        return "MacroFedStrategy"
    
    async def get_yield_snapshot(self, ticker: str = "^IRX") -> YieldSnapshot:
        """
        Get current yield with statistical context.
        
        Args:
            ticker: Yahoo Finance ticker (default: ^IRX for 13-week T-Bill)
            
        Returns:
            YieldSnapshot with z-score and analysis
        """
        # Fetch historical data
        history = await self.yahoo.get_history(
            ticker, 
            period=self.rolling_period, 
            interval=self.rolling_interval
        )
        
        snapshot = YieldSnapshot(
            ticker=ticker,
            current_yield=history.latest,
            mean_yield=history.mean,
            std_dev=history.std,
            z_score=history.z_score(),
            period=self.rolling_period,
            data_points=len(history.prices),
        )
        
        self._last_yield = snapshot
        self._yield_history.append(snapshot)
        
        logger.info(f"Yield snapshot: {snapshot}")
        return snapshot
    
    async def get_fed_meeting_events(self) -> Dict[str, List[MarketWithOrderbook]]:
        """
        Scan specific Fed meeting events (KXFED-26JAN, etc.).
        
        Returns:
            Dictionary mapping event ticker to list of markets
        """
        events: Dict[str, List[MarketWithOrderbook]] = {}
        
        for event_ticker in self.FED_MEETING_EVENTS:
            try:
                markets = self.scanner.scan_event(event_ticker, min_volume=0)
                if markets:
                    events[event_ticker] = markets
                    logger.debug(f"Found {len(markets)} markets in {event_ticker}")
            except Exception as e:
                logger.debug(f"No markets for {event_ticker}: {e}")
        
        return events
    
    async def get_fed_markets(self) -> FedMarketSnapshot:
        """
        Scan Kalshi for Fed-related markets and categorize them.
        
        Returns:
            FedMarketSnapshot with categorized markets
        """
        all_markets: List[MarketWithOrderbook] = []
        
        # Scan all Fed series
        for series in self.FED_SERIES:
            try:
                markets = self.scanner.scan_series(series, min_volume=0)
                all_markets.extend(markets)
                logger.debug(f"Found {len(markets)} markets in {series}")
            except Exception as e:
                logger.warning(f"Error scanning {series}: {e}")
        
        # Categorize markets
        hike_markets = []
        cut_markets = []
        hold_markets = []
        
        for market in all_markets:
            title = market.market.title.lower()
            
            if any(kw in title for kw in self.HIKE_KEYWORDS):
                hike_markets.append(market)
            elif any(kw in title for kw in self.CUT_KEYWORDS):
                cut_markets.append(market)
            elif any(kw in title for kw in self.HOLD_KEYWORDS):
                hold_markets.append(market)
            else:
                # Try to categorize by analyzing the contract structure
                # Markets with "at least X%" where X > current rate ‚Üí hike
                # Markets with "below X%" ‚Üí cut
                logger.debug(f"Uncategorized Fed market: {market.market.title}")
        
        # Calculate implied probabilities (use mid of yes_bid and yes_ask)
        def get_avg_prob(markets: List[MarketWithOrderbook]) -> float:
            if not markets:
                return 0.0
            valid_probs = []
            for m in markets:
                if not m.pricing:
                    continue
                bid = m.pricing.best_yes_bid
                ask = m.pricing.best_yes_ask
                if bid and ask:
                    mid = (bid + ask) / 2
                    valid_probs.append(mid)
                elif ask:
                    valid_probs.append(ask)
                elif bid:
                    valid_probs.append(bid)
            return sum(valid_probs) / len(valid_probs) if valid_probs else 0.0
        
        snapshot = FedMarketSnapshot(
            series_ticker="KXFED",
            hike_markets=hike_markets,
            cut_markets=cut_markets,
            hold_markets=hold_markets,
            total_hike_prob=get_avg_prob(hike_markets),
            total_cut_prob=get_avg_prob(cut_markets),
            hold_prob=get_avg_prob(hold_markets),
        )
        
        self._last_fed_snapshot = snapshot
        logger.info(f"Fed markets: {snapshot}")
        return snapshot
    
    def _classify_market_action(self, market: MarketWithOrderbook) -> Optional[FedAction]:
        """Classify a market as HIKE, CUT, or HOLD based on title."""
        title = market.market.title.lower()
        
        if any(kw in title for kw in self.HIKE_KEYWORDS):
            return FedAction.HIKE
        elif any(kw in title for kw in self.CUT_KEYWORDS):
            return FedAction.CUT
        elif any(kw in title for kw in self.HOLD_KEYWORDS):
            return FedAction.HOLD
        return None
    
    def _generate_correlation_signals(
        self,
        yield_snap: YieldSnapshot,
        fed_snap: FedMarketSnapshot,
    ) -> List[CorrelationSignal]:
        """
        Generate trading signals based on yield/Kalshi correlation.
        
        Logic:
        - If yield spikes (z > 2) but Kalshi hike prob is low ‚Üí BUY HIKE
        - If yield dumps (z < -2) but Kalshi cut prob is low ‚Üí BUY CUT
        """
        signals = []
        
        # No signal if yield is within normal range
        if yield_snap.signal_direction is None:
            logger.info("Yield within normal range - no signals")
            return signals
        
        if yield_snap.is_spike:
            # Yield spiking ‚Üí Market expects hikes
            # If Kalshi hike prob is low, that's an opportunity
            for market in fed_snap.hike_markets:
                if not market.pricing:
                    continue
                    
                ask = market.pricing.best_yes_ask
                if ask and ask < 50:  # Implied prob < 50% = underpriced
                    signal = Signal(
                        ticker=market.market.ticker,
                        side=Side.BUY,
                        price=int(ask),
                        size=self.default_size,
                        strategy_name=self.name,
                        confidence=min(abs(yield_snap.z_score) / 4.0, 1.0),
                        metadata={
                            "z_score": yield_snap.z_score,
                            "yield": yield_snap.current_yield,
                            "market_type": "HIKE",
                        }
                    )
                    
                    signals.append(CorrelationSignal(
                        signal=signal,
                        yield_snapshot=yield_snap,
                        kalshi_market=market,
                        rationale=f"Yield spike (z={yield_snap.z_score:+.2f}) but hike prob only {ask:.0f}¬¢",
                        confidence=signal.confidence,
                    ))
            
            # Also consider selling cut contracts
            for market in fed_snap.cut_markets:
                if not market.pricing:
                    continue
                    
                bid = market.pricing.best_yes_bid
                if bid and bid > 50:  # Implied prob > 50% = overpriced
                    signal = Signal(
                        ticker=market.market.ticker,
                        side=Side.SELL,
                        price=int(bid),
                        size=self.default_size,
                        strategy_name=self.name,
                        confidence=min(abs(yield_snap.z_score) / 4.0, 1.0),
                        metadata={
                            "z_score": yield_snap.z_score,
                            "yield": yield_snap.current_yield,
                            "market_type": "CUT",
                        }
                    )
                    
                    signals.append(CorrelationSignal(
                        signal=signal,
                        yield_snapshot=yield_snap,
                        kalshi_market=market,
                        rationale=f"Yield spike (z={yield_snap.z_score:+.2f}) but cut prob still {bid:.0f}¬¢",
                        confidence=signal.confidence,
                    ))
        
        elif yield_snap.is_dump:
            # Yield dumping ‚Üí Market expects cuts
            # If Kalshi cut prob is low, that's an opportunity
            for market in fed_snap.cut_markets:
                if not market.pricing:
                    continue
                    
                ask = market.pricing.best_yes_ask
                if ask and ask < 50:
                    signal = Signal(
                        ticker=market.market.ticker,
                        side=Side.BUY,
                        price=int(ask),
                        size=self.default_size,
                        strategy_name=self.name,
                        confidence=min(abs(yield_snap.z_score) / 4.0, 1.0),
                        metadata={
                            "z_score": yield_snap.z_score,
                            "yield": yield_snap.current_yield,
                            "market_type": "CUT",
                        }
                    )
                    
                    signals.append(CorrelationSignal(
                        signal=signal,
                        yield_snapshot=yield_snap,
                        kalshi_market=market,
                        rationale=f"Yield dump (z={yield_snap.z_score:+.2f}) but cut prob only {ask:.0f}¬¢",
                        confidence=signal.confidence,
                    ))
            
            # Also consider selling hike contracts
            for market in fed_snap.hike_markets:
                if not market.pricing:
                    continue
                    
                bid = market.pricing.best_yes_bid
                if bid and bid > 50:
                    signal = Signal(
                        ticker=market.market.ticker,
                        side=Side.SELL,
                        price=int(bid),
                        size=self.default_size,
                        strategy_name=self.name,
                        confidence=min(abs(yield_snap.z_score) / 4.0, 1.0),
                        metadata={
                            "z_score": yield_snap.z_score,
                            "yield": yield_snap.current_yield,
                            "market_type": "HIKE",
                        }
                    )
                    
                    signals.append(CorrelationSignal(
                        signal=signal,
                        yield_snapshot=yield_snap,
                        kalshi_market=market,
                        rationale=f"Yield dump (z={yield_snap.z_score:+.2f}) but hike prob still {bid:.0f}¬¢",
                        confidence=signal.confidence,
                    ))
        
        return signals
    
    async def run(self) -> List[CorrelationSignal]:
        """
        Run the correlation strategy.
        
        Fetches current yield data and Kalshi markets, then generates signals.
        
        Returns:
            List of CorrelationSignal objects
        """
        logger.info("Running MacroFedStrategy...")
        
        # Fetch data in parallel
        yield_task = self.get_yield_snapshot("^IRX")
        fed_task = self.get_fed_markets()
        
        yield_snap, fed_snap = await asyncio.gather(yield_task, fed_task)
        
        # Generate signals
        signals = self._generate_correlation_signals(yield_snap, fed_snap)
        self._signals = signals
        
        logger.info(f"Generated {len(signals)} signals")
        return signals
    
    def generate_signals(self, market_data: List[Any]) -> List[Signal]:
        """
        Implementation of Strategy abstract method.
        
        Note: For this strategy, use run() instead as it handles async data fetching.
        This method is provided for interface compatibility.
        """
        if self._signals:
            return [cs.signal for cs in self._signals]
        return []
    
    def get_state(self) -> Dict[str, Any]:
        """
        Get current strategy state for monitoring.
        
        Returns:
            Dictionary with yield, market, and signal state
        """
        return {
            "last_yield": str(self._last_yield) if self._last_yield else None,
            "last_fed_snapshot": str(self._last_fed_snapshot) if self._last_fed_snapshot else None,
            "signal_count": len(self._signals),
            "yield_history_count": len(self._yield_history),
        }


# =============================================================================
# RUNNER FUNCTION
# =============================================================================

async def run_macro_fed_strategy(
    key_id: str,
    key_file_path: str,
    z_threshold: float = 2.0,
    verbose: bool = False,
) -> List[CorrelationSignal]:
    """
    Convenience function to run the MacroFed strategy.
    
    Args:
        key_id: Kalshi API key ID
        key_file_path: Path to Kalshi private key
        z_threshold: Z-score threshold for signals
        verbose: Print detailed output
        
    Returns:
        List of generated signals
    """
    from pathlib import Path
    
    print("=" * 70)
    print("üè¶ MACRO FED CORRELATION STRATEGY")
    print("=" * 70)
    print(f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Z-Score Threshold: ¬±{z_threshold}")
    print()
    
    # Initialize adapters
    print("üîå Initializing adapters...")
    yahoo = YahooAdapter()
    kalshi = KalshiAdapter(key_id, Path(key_file_path))
    
    # Create strategy
    strategy = MacroFedStrategy(
        yahoo_adapter=yahoo,
        kalshi_adapter=kalshi,
        z_score_threshold=z_threshold,
    )
    
    # Run strategy
    print("üìä Fetching yield data and Kalshi markets...")
    signals = await strategy.run()
    
    # Display results
    print()
    print("=" * 70)
    print("üìà YIELD ANALYSIS")
    print("=" * 70)
    
    yield_snap = strategy._last_yield
    if yield_snap:
        print(f"  Ticker:      ^IRX (13-Week T-Bill)")
        print(f"  Current:     {yield_snap.current_yield:.4f}%")
        print(f"  Mean ({yield_snap.period}):  {yield_snap.mean_yield:.4f}%")
        print(f"  Std Dev:     {yield_snap.std_dev:.4f}%")
        print(f"  Z-Score:     {yield_snap.z_score:+.4f}")
        print(f"  Data Points: {yield_snap.data_points}")
        print()
        
        if yield_snap.is_spike:
            print("  ‚ö†Ô∏è  YIELD SPIKE DETECTED (z > 2.0)")
            print("      ‚Üí Market expects Fed to HIKE rates")
        elif yield_snap.is_dump:
            print("  ‚ö†Ô∏è  YIELD DUMP DETECTED (z < -2.0)")
            print("      ‚Üí Market expects Fed to CUT rates")
        else:
            print("  ‚ÑπÔ∏è  Yield within normal range")
            print(f"      (|z| = {abs(yield_snap.z_score):.2f} < 2.0)")
    
    # Display Fed Meeting Events (the key markets)
    print()
    print("=" * 70)
    print("üìÖ FED FUNDS RATE MEETINGS (KXFED Events)")
    print("=" * 70)
    
    fed_events = await strategy.get_fed_meeting_events()
    
    if fed_events:
        for event_ticker, markets in sorted(fed_events.items())[:6]:  # Show first 6 events
            print(f"\n  üìÖ {event_ticker}")
            print("  " + "-" * 40)
            
            # Sort markets by rate threshold (extract from ticker like T4.25)
            markets_sorted = sorted(
                markets, 
                key=lambda m: m.market.ticker,
                reverse=True
            )
            
            # Show markets with actual liquidity
            liquid_markets = [
                m for m in markets_sorted 
                if m.pricing and (m.pricing.best_yes_bid or m.pricing.best_yes_ask)
            ]
            
            if liquid_markets:
                for m in liquid_markets[:5]:
                    bid = m.pricing.best_yes_bid if m.pricing and m.pricing.best_yes_bid else "-"
                    ask = m.pricing.best_yes_ask if m.pricing and m.pricing.best_yes_ask else "-"
                    vol = m.market.volume_24h
                    
                    # Extract rate level from ticker (e.g., T4.25 from KXFED-26JAN-T4.25)
                    ticker_parts = m.market.ticker.split("-")
                    rate_level = ticker_parts[-1] if len(ticker_parts) >= 3 else "?"
                    
                    bid_str = f"{bid:.0f}¬¢" if isinstance(bid, (int, float)) else bid
                    ask_str = f"{ask:.0f}¬¢" if isinstance(ask, (int, float)) else ask
                    
                    print(f"    {rate_level}: Bid {bid_str} | Ask {ask_str} | Vol: {vol}")
            else:
                print(f"    (No liquid markets)")
    else:
        print("  No Fed meeting events found")
    
    print()
    print("=" * 70)
    print("üé≤ KALSHI FED MARKETS (Summary)")
    print("=" * 70)
    
    fed_snap = strategy._last_fed_snapshot
    if fed_snap:
        print(f"  Hike Markets: {len(fed_snap.hike_markets)}")
        print(f"  Cut Markets:  {len(fed_snap.cut_markets)}")
        print(f"  Hold Markets: {len(fed_snap.hold_markets)}")
        print()
        print(f"  Avg Hike Prob: {fed_snap.total_hike_prob:.1f}¬¢")
        print(f"  Avg Cut Prob:  {fed_snap.total_cut_prob:.1f}¬¢")
        print(f"  Avg Hold Prob: {fed_snap.hold_prob:.1f}¬¢")
        
        if verbose:
            print()
            print("  Detailed Markets:")
            for m in fed_snap.hike_markets[:5]:
                ask = m.pricing.best_yes_ask if m.pricing else "N/A"
                print(f"    [HIKE] {m.market.ticker}: {m.market.title[:40]}... (ask={ask}¬¢)")
            for m in fed_snap.cut_markets[:5]:
                ask = m.pricing.best_yes_ask if m.pricing else "N/A"
                print(f"    [CUT]  {m.market.ticker}: {m.market.title[:40]}... (ask={ask}¬¢)")
    
    print()
    print("=" * 70)
    print("üì£ TRADING SIGNALS")
    print("=" * 70)
    
    if signals:
        print(f"  Generated {len(signals)} signals:")
        print()
        for i, cs in enumerate(signals, 1):
            print(f"  {i}. {cs.signal.side.value} {cs.signal.ticker}")
            print(f"     Price: {cs.signal.price}¬¢")
            print(f"     Size: {cs.signal.size}")
            print(f"     Confidence: {cs.confidence:.0%}")
            print(f"     Rationale: {cs.rationale}")
            print()
    else:
        print("  ‚úÖ No trading signals generated")
        print("     (Yield within normal range OR markets already priced correctly)")
    
    print("=" * 70)
    
    return signals

